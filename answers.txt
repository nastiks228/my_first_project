ПР1

1. Какие три основные области работы с файлами в Git (рабочая папка, индекс, репозиторий) и чем они отличаются?

- Рабочая папка (Working Directory) - это текущее состояние файлов в вашей локальной директории, где вы непосредственно работаете с кодом
- Индекс (Staging Area) - промежуточная область, куда добавляются файлы перед коммитом. Здесь вы формируете "снимок" изменений для следующего коммита
- Репозиторий (Repository) - база данных Git, хранящая всю историю проекта, коммиты, ветки и метаданные

2. Что происходит при выполнении команд:
   o git add
   o git commit
   o git push

- git add - добавляет изменения из рабочей папки в индекс (staging area), подготавливая их к коммиту
- git commit - создает новый коммит из проиндексированных изменений, сохраняя их в локальный репозиторий с указанным сообщением
- git push - отправляет локальные коммиты в удаленный репозиторий, синхронизируя изменения с другими разработчиками

3. Почему важно писать информативные сообщения к коммитам а не просто "исправление" или "update"?

Информативные сообщения важны потому, что:
- Они объясняют ЗАЧЕМ были сделаны изменения, а не только ЧТО изменилось
- Помогают другим разработчикам (и вам самим в будущем) понять логику изменений
- Упрощают поиск конкретных изменений в истории
- Облегчают отладку и анализ проблем
- Делают историю проекта более читаемой и понятной

4. Чем отличается git add имя_файла от git add .? В каких случаях лучше использовать каждый вариант?

- git add имя_файла - добавляет в индекс только указанный файл. Лучше использовать когда нужно тщательно контролировать какие изменения попадут в коммит
- git add . - добавляет все измененные файлы в текущей директории и поддиректориях. Удобно когда нужно добавить все изменения сразу

Рекомендации по использованию:
- git add имя_файла - для точного контроля, когда меняете несколько файлов но хотите коммитить их отдельно
- git add . - когда все изменения в проекте связаны с одной задачей и могут быть закоммичены вместе

5. Что показывает команда git status и как меняется ее вывод на разных этапах работы?

git status показывает текущее состояние рабочей папки и индекса. Вывод меняется в зависимости от этапа:

- При наличии неотслеживаемых файлов: показывает "Untracked files"
- При изменении отслеживаемых файлов: показывает "Changes not staged for commit"
- После git add: показывает "Changes to be committed"
- После git commit: показывает "nothing to commit, working tree clean"
- При расхождении с удаленным репозиторием: показывает информацию о ahead/behind

6. Для чего нужна команда git remote add origin URL и что означает слово "origin"?

Команда git remote add origin URL добавляет удаленный репозиторий с именем "origin" и указанным URL.

Слово "origin" - это стандартное имя для основного удаленного репозитория (обычно на GitHub, GitLab и т.д.), но можно использовать любое другое имя. Это псевдоним для удобства работы с удаленным репозиторием.

7. Зачем нужен флаг -u в команде git push -u origin main при первой отправке изменений?

Флаг -u (или --set-upstream) устанавливает постоянную связь между локальной веткой и удаленной веткой. После его использования:
- Git запоминает что локальная ветка main связана с origin/main
- В дальнейшем можно использовать просто git push без указания параметров
- Команда git pull также будет автоматически работать с правильной веткой

8. Что такое ветка (branch) по умолчанию и какая у вас создалась (main или master)? Почему это важно?

Ветка по умолчанию - это основная ветка проекта. В современных версиях Git создается ветка main.

Это важно потому, что:
- Это основная ветка разработки проекта
- По умолчанию в нее делаются коммиты
- Она считается стабильной версией проекта
- При клонировании репозитория автоматически переключается на эту ветку
- С нее обычно начинается разработка новых функций

9. Как просмотреть историю коммитов и какую информацию о каждом коммите вы видите?

Для просмотра истории коммитов используется команда git log.

Информация о каждом коммите включает:
- Хеш коммита (уникальный идентификатор, например: abc123def456)
- Автора коммита (имя и email)
- Дату и время создания коммита
- Сообщение коммита

Дополнительные опции:
- git log --oneline - компактный вывод
- git log --graph - визуализация ветвления
- git log -p - показывает изменения в файлах

10. Что произойдет, если сделать изменения в файле, но не выполнить git add перед git commit?

Если сделать изменения в файле но не выполнить git add перед git commit, то:
- Эти изменения НЕ будут включены в коммит
- Git проигнорирует неподготовленные изменения
- Файлы останутся в состоянии "modified" в рабочей папке
- Потребуется отдельно добавить и закоммитить эти изменения позже
- Коммит будет создан только из тех изменений, которые были предварительно добавлены в индекс с помощью git add







ПР2
1. Чем семантическая верстка отличается от несемантической и почему она важна?

Ответ:
Семантическая верстка использует HTML-теги, которые несут смысловое значение (например, <article>, <nav>, <header>), тогда как несемантическая relies на теги без смысловой нагрузки (например, <div>, <span>).

Важность семантической верстки:
- Улучшает доступность для людей с ограниченными возможностями
- Повышает SEO (поисковые системы лучше понимают структуру контента)
- Упрощает чтение и поддержку кода
- Обеспечает лучшую совместимость с различными устройствами

2. В каких случаях следует использовать <article> вместо <section>? Приведите примеры из вашей работы.

Ответ:
<article> используется для самостоятельного, независимого контента, который может быть извлечен из страницы и оставаться понятным. <section> - для группировки тематического контента в рамках документа.

Примеры использования:
- <article>: карточка товара, пост в блоге, новость, комментарий
- <section>: глава статьи, группа связанных товаров, блок "о компании"

3. Для чего предназначены теги <header> и <footer> и могут ли они использоваться несколько раз на странице?

Ответ:
<header> - для вводного контента или навигации секции/страницы
<footer> - для заключительной информации секции/страницы

Да, они могут использоваться несколько раз! Каждый <article> и <section> может иметь собственные <header> и <footer>.

4. Какой тег следует использовать для основного контента страницы и почему не стоит использовать для этого <div>?

Ответ:
Для основного контента следует использовать тег <main>. 

Почему не <div>:
- <div> не несет семантического значения
- Скринридеры и поисковые системы не понимают важность контента в <div>
- <main> четко определяет основное содержание страницы

5. В чем разница между <nav> и обычным списком ссылок? Когда обязательно использовать <nav>?

Ответ:
<nav> семантически обозначает блок навигации, тогда как обычный список ссылок - просто группа ссылок без специального значения.

Обязательно использовать <nav> для:
- Основной навигации по сайту
- Блоков связанных ссылок (пагинация, меню категорий)
Не обязательно для: небольших групп ссылок в подвале, списка социальных сетей

6. Для чего используется атрибут datetime в теге <time> и почему он важен?

Ответ:
Атрибут datetime предоставляет машиночитаемую версию времени/даты, тогда как содержимое тега - человекочитаемую.

Пример:
<time datetime="2023-10-15T14:30:00+03:00">15 октября 2023, 14:30</time>

Важность:
- Поисковые системы понимают точное время
- Браузеры могут предлагать добавление в календарь
- Улучшает доступность для скринридеров

7. Какие преимущества дает использование <figure> и <figcaption> вместо простого <img> с подписью?

Ответ:
Преимущества:
- Семантическая связь между изображением и подписью
- Улучшенная доступность (скринридеры объявляют связь)
- Лучшее понимание контента поисковыми системами
- Возможность группировать несколько медиа-элементов с одной подписью

8. Когда следует использовать <aside> и какой контент в него помещать?

Ответ:
<aside> используется для контента, косвенно связанного с основным содержанием.

Примеры контента для <aside>:
- Боковая панель с дополнительной информацией
- Блок "похожие товары"
- Цитаты, рекламные баннеры
- Дополнительные ссылки и ресурсы

9. Как семантическая разметка влияет на SEO и доступность веб-страницы?

Ответ:
Влияние на SEO:
- Поисковые системы лучше понимают структуру и важность контента
- Улучшается релевантность страницы поисковым запросам
- Возможность получения расширенных сниппетов в поисковой выдаче

Влияние на доступность:
- Скринридеры могут правильно ориентировать пользователей
- Упрощается навигация с клавиатуры
- Улучшается опыт пользователей с ограниченными возможностями

10. Какие теги вы использовали для улучшения структуры документа и как они помогают пользователям и поисковым системам?

Ответ:
Использованные семантические теги:
- <header> - для шапки сайта
- <nav> - для основной навигации
- <main> - для основного контента
- <article> - для самостоятельных блоков контента
- <section> - для группировки связанного контента
- <aside> - для дополнительной информации
- <footer> - для подвала сайта

Помощь пользователям и поисковым системам:
- Четкая структура документа
- Легкая навигация по контенту
- Понимание иерархии информации
- Улучшенный пользовательский опыт






ПР3

1. В чем разница между селектором по классу и по ID с точки зрения специфичности и возможности повторного использования?

Разница в специфичности:
- ID селектор (#id) имеет специфичность 0,1,0,0 (высокая)
- Class селектор (.class) имеет специфичность 0,0,1,0 (средняя)

Разница в повторном использовании:
- Классы можно использовать многократно на одной странице
- ID должен быть уникальным на странице (только один элемент)

2. Как работает каскад в CSS и в каком порядке применяются стили при конфликте правил?

Каскад работает по принципу приоритетов в порядке:
1. Важность (!important)
2. Специфичность селектора
3. Порядок в исходном коде (последнее правило имеет приоритет)

Порядок разрешения конфликтов:
- Стили с !important
- Встроенные стили (style attribute)
- ID селекторы
- Class селекторы, псевдоклассы, атрибуты
- Элементные селекторы, псевдоэлементы
- Унаследованные стили

3. Рассчитайте специфичность для селекторов:
   o ul li.important
   o #site-title
   o .content > .featured-post

- ul li.important: 0,0,1,2 (2 элемента + 1 класс)
- #site-title: 0,1,0,0 (1 ID)
- .content > .featured-post: 0,0,2,0 (2 класса)

4. Какие свойства в CSS наследуются по умолчанию, а какие нет? Приведите по 3 примера каждого типа.

Наследуемые свойства:
- color
- font-family
- line-height

Ненаследуемые свойства:
- background
- border
- margin

5. Как работает селектор > (дочерний селектор) и чем он отличается от селектора потомков (через пробел)?

Дочерний селектор (>) выбирает только прямых потомков:
- .parent > .child - выберет только непосредственные дочерние элементы

Селектор потомков (пробел) выбирает всех потомков любого уровня вложенности:
- .parent .child - выберет все элементы .child внутри .parent на любой глубине

6. Для чего используются псевдоклассы :hover и :nth-child()? В каких практических задачах они могут пригодиться?

:hover - применяет стили при наведении курсора:
- Кнопки, ссылки, карточки товаров

:nth-child() - выбирает элементы по их порядковому номеру:
- Полосатые таблицы
- Выделение каждых 3-х элементов в сетке
- Специфичное оформление определенных позиций в списке

7. Что делает правило !important и почему его следует использовать с осторожностью?

!important повышает приоритет свойства, делая его самым важным.

Почему использовать осторожно:
- Нарушает естественный каскад CSS
- Усложняет переопределение стилей
- Может привести к "войне !important"
- Затрудняет поддержку кода

8. Как псевдоэлементы ::before и ::after расширяют возможности CSS и какой контент они могут содержать?

::before и ::after создают псевдоэлементы внутри выбранного элемента.

Что могут содержать:
- Текст (content: "Текст")
- Иконки (content: "★")
- Декоративные элементы
- Номера, счетчики
- Пустое пространство для оформления

9. В каком порядке браузер применяет CSS-правила при одинаковой специфичности селекторов?

При одинаковой специфичности браузер применяет:
1. Последнее правило в CSS файле (по порядку в коде)
2. Более поздние импорты имеют приоритет
3. Встроенные стили в HTML имеют высший приоритет (кроме !important)

10. Как инструменты разработчика в браузере помогают анализировать и отлаживать CSS-код?

Возможности инструментов разработчика:
- Просмотр вычисленных стилей элемента
- Изменение CSS в реальном времени
- Отладка медиа-запросов
- Анализ специфичности селекторов
- Просмотр наследуемых свойств
- Эмуляция различных состояний (:hover, :focus)
